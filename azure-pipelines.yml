trigger:
  branches:
    include:
      - dev
      - main

pool:
  name: default  # Nombre de tu pool/agent

variables:
  imageName: 'jrebaza01/app-week1'
  # tag lo usamos con Build.SourceVersion en tiempo de ejecuci√≥n

steps:

# 1Ô∏è‚É£ Calcula releaseName / namespace seg√∫n rama (persistente para el job)
- script: |
    echo "=> Determinando releaseName/namespace seg√∫n la rama: $(Build.SourceBranchName)"
    if [ "$(Build.SourceBranchName)" == "dev" ]; then
      echo "##vso[task.setvariable variable=RELEASE_NAME]app-dev"
      echo "##vso[task.setvariable variable=NAMESPACE]dev"
    else
      echo "##vso[task.setvariable variable=RELEASE_NAME]app-prod"
      echo "##vso[task.setvariable variable=NAMESPACE]prod"
    fi
  displayName: 'Set releaseName and namespace dynamically'
  name: SetVars

# 2Ô∏è‚É£ Debug r√°pido para asegurarnos de que las variables existen (fallar√° si est√°n vac√≠as)
- script: |
    echo "DEBUG: RELEASE_NAME = '$(RELEASE_NAME)'"
    echo "DEBUG: NAMESPACE    = '$(NAMESPACE)'"
    if [ -z "$(RELEASE_NAME)" ] || [ -z "$(NAMESPACE)" ]; then
      echo "ERROR: RELEASE_NAME o NAMESPACE vac√≠o. Abortando."
      exit 1
    fi
  displayName: 'Debug variables (fail fast)'

# 3Ô∏è‚É£ Checkout del repo (usa persistCredentials para poder push con PAT)
- checkout: self
  persistCredentials: true
  displayName: 'Checkout repository'

# 4Ô∏è‚É£ Actualiza envs/*/values.yaml y push a GitHub usando PAT (evita SSH)
- bash: |
    set -e
    echo "=== üîß Updating values.yaml for branch $(Build.SourceBranchName) ==="

    if [ "$(Build.SourceBranchName)" == "dev" ]; then
      envPath="envs/dev/values.yaml"
    else
      envPath="envs/prod/values.yaml"
    fi

    # Actualiza tag (si no quieres tag simplemente usa 'latest' fijo)
    sed -i "s|tag: .*|tag: $(Build.SourceVersion)|" "$envPath" || true

    git config user.email "pipeline@azuredevops.local"
    git config user.name "Azure Pipelines"
    git add "$envPath"
    git commit -m "Update values.yaml for $(Build.SourceBranchName) -> $(Build.SourceVersion)" || echo "No changes to commit"

    # Push usando PAT
    # Nota: GITHUB_PAT debe ser una Variable de pipeline (secret).
    git remote set-url origin https://$(GITHUB_PAT)@github.com/jreb-123/k8s-lab-week1.git
    git pull origin $(Build.SourceBranchName) --rebase || true
    git push origin HEAD:$(Build.SourceBranchName)
  displayName: 'Update Helm values.yaml and push to GitHub via PAT'
  env:
    GITHUB_PAT: $(GITHUB_PAT)

# 5Ô∏è‚É£ Build Docker image (ajusta containerRegistry si usas conexi√≥n distinta)
- task: Docker@2
  displayName: 'Build Docker image'
  inputs:
    command: build
    Dockerfile: '$(Build.SourcesDirectory)/app/Dockerfile'
    buildContext: '$(Build.SourcesDirectory)/app'
    tags: |
      $(imageName):$(Build.SourceVersion)

# 6Ô∏è‚É£ Push Docker image to Docker Hub (ajusta containerRegistry)
- task: Docker@2
  displayName: 'Push Docker image to Docker Hub'
  inputs:
    command: push
    tags: |
      $(imageName):$(Build.SourceVersion)

# 7Ô∏è‚É£ Debug variables antes de Helm (√∫til para logs)
- script: |
    echo "PRE-HELM: RELEASE_NAME='$(RELEASE_NAME)'"
    echo "PRE-HELM: NAMESPACE='$(NAMESPACE)'"
    echo "PRE-HELM: IMAGE='$(imageName):$(Build.SourceVersion)'"
  displayName: 'Debug variables before Helm'

# 8Ô∏è‚É£ Deploy a AKS via Helm (upgrade --install). NO wait para evitar timeouts largos.
- task: HelmDeploy@0
  displayName: 'Deploy to Kubernetes via Helm'
  inputs:
    connectionType: 'Kubernetes Service Connection'
    kubernetesServiceConnection: 'aks-kubeconfig-connection'
    command: 'upgrade'
    chartType: 'FilePath'
    chartPath: 'charts/app'
    releaseName: '$(RELEASE_NAME)'
    namespace: '$(NAMESPACE)'
    overrideValues: 'image.repository=$(imageName),image.tag=$(Build.SourceVersion)'
    install: true
    waitForExecution: false
    arguments: '--create-namespace'

# 9Ô∏è‚É£ Comprobaci√≥n del estado del release (usa HelmDeploy status ‚Äî con RELEASE_NAME ya establecido)
- task: HelmDeploy@0
  displayName: 'Check deployment status (helm status)'
  inputs:
    connectionType: 'Kubernetes Service Connection'
    kubernetesServiceConnection: 'aks-kubeconfig-connection'
    command: 'status'
    releaseName: '$(RELEASE_NAME)'
    namespace: '$(NAMESPACE)'
